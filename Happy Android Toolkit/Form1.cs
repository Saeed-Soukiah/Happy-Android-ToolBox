/* =============================================================================
 * Android Toolkit - WinForms ADB Utility
 * -----------------------------------------------------------------------------
 * Author      : Saeed Soukiah
 * Created On  : November 15, 2025
 * Description : A Windows Forms application for managing Android devices via ADB.
 *               Features include device listing, APK installation, reboot modes,
 *               file push/pull, batch operations, and factory reset.
 *               Designed for extensibility and portfolio-quality robustness.
 * =============================================================================
 */

// Import common base types and utilities from the .NET runtime
using System.Diagnostics; // Process start and diagnostics
using System.Text; // StringBuilder
using Microsoft.VisualBasic; // Interaction.InputBox helper used for simple input dialogs

// Declare the application's namespace to avoid name collisions
namespace android_toolkit
{
    /// <summary>
    /// Main form for the Android Toolkit.
    /// This class implements UI handlers and adb orchestration logic for a WinForms application.
    /// Each method below interacts with adb via Process and updates UI safely from background tasks.
    /// </summary>
    public partial class Form1 : Form
    {
        // Candidate paths for adb. "adb" relies on PATH; others are common Windows install locations.
        private readonly string[] AdbCandidates = new[]
        {
            "adb", // prefer generic executable name (relies on PATH)
            @"C:\platform-tools\adb.exe", // common manual install location
            @"C:\Program Files (x86)\Android\platform-tools\adb.exe", // possible SDK install path (32-bit Program Files)
            @"C:\Program Files\Android\platform-tools\adb.exe" // possible SDK install path (64-bit Program Files)
        };

        // Lazily resolved adb path or null if not found.
        // Accessing AdbPath calls ResolveAdbPath() each time (simple lazy lookup).
        private string? AdbPath => ResolveAdbPath();

        // Serial of currently selected device in DevicesListBox (first token of the display line).
        // If null, actions target any connected device (adb default behavior).
        private string? selectedDeviceSerial = null;

        /// <summary>
        /// Constructor. Attaches UI event handlers and triggers initial device refresh on form load.
        /// </summary>
        public Form1()
        {
            InitializeComponent(); // Initialize form controls generated by the Designer.

            // Wire up existing control event handlers only if those controls were created by the Designer.
            if (Reboot != null) Reboot.Click += button1_Click; // Reboot button -> reboot handler
            if (ChooseAPK != null) ChooseAPK.Click += button2_Click; // Choose APK button -> open file dialog
            if (InstallApk != null) InstallApk.Click += button3_Click; // Install button -> install handler
            if (openFileDialog1 != null) openFileDialog1.FileOk += openFileDialog1_FileOk; // OpenFileDialog OK event
            if (textBox1 != null) textBox1.TextChanged += textBox1_TextChanged; // Text changed handler for apk path textbox

            // Reboot / bootloader / recovery / format UI handlers
            if (Format != null) Format.Click += Format_Click; // Format (factory reset) handler
            if (Downloadmode != null) Downloadmode.Click += Downloadmode_Click; // Reboot to bootloader
            if (Recovery != null) Recovery.Click += Recovery_Click; // Reboot to recovery

            // Device-listing handlers
            if (RefreshDevices != null) RefreshDevices.Click += RefreshDevices_Click; // Refresh device list button
            if (DevicesListBox != null) DevicesListBox.SelectedIndexChanged += DevicesListBox_SelectedIndexChanged; // Selection changed

            // Additional feature buttons wired to their implementations if created in Designer
            if (PushFileBtn != null) PushFileBtn.Click += PushFile_Click; // Push file to device
            if (PullFileBtn != null) PullFileBtn.Click += PullFile_Click; // Pull file from device
            if (BatchInstallBtn != null) BatchInstallBtn.Click += BatchInstall_Click; // Batch install APKs
            if (BatchUninstallBtn != null) BatchUninstallBtn.Click += BatchUninstall_Click; // Batch uninstall packages
            if (ShowDeviceInfoBtn != null) ShowDeviceInfoBtn.Click += ShowDeviceInfo_Click; // Show diagnostics

            // Populate device list on form Load without blocking UI: subscribe to Load event with async handler
            this.Load += async (s, e) => await RefreshDeviceListAsync();
        }

        #region Reboot / Install / Choose APK

        /// <summary>
        /// Normal reboot action (adb reboot). Targets selected device if any.
        /// This is an async void handler wired to a button click; performs validations then calls adb.
        /// </summary>
        private async void button1_Click(object? sender, EventArgs e)
        {
            // Ensure adb is available; if not present, user already notified and we exit early.
            if (!EnsureAdbAvailable()) return;

            // Query connected devices to ensure at least one authorized device is present
            var devicesResult = await RunAdbCommandAsync("devices");

            // If no authorized device found and no device explicitly selected, show warning and abort
            if (!IsDeviceConnected(devicesResult.Output) && selectedDeviceSerial == null)
            {
                AppendLog("Reboot skipped: no connected/authorized device."); // Add log entry
                MessageBox.Show("No device detected or device unauthorized. Run adb devices and accept the USB debugging prompt on the device.", "ADB Device", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return; // nothing to do
            }

            // Log the reboot command and the target device (selected serial or any)
            AppendLog($"Running: adb reboot (target: {selectedDeviceSerial ?? "any"})");

            // Execute adb reboot, targeting -s <serial> when selectedDeviceSerial != null
            var result = await RunAdbCommandAsync("reboot", selectedDeviceSerial);

            // Log the result: exit code and trimmed stderr/stdout content
            AppendLog($"Reboot result Exit:{result.ExitCode} Err:{result.Error.Trim()} Out:{result.Output.Trim()}");

            // If exit code 0 and no stderr content, consider it success; otherwise notify user to check log
            if (result.ExitCode == 0 && string.IsNullOrWhiteSpace(result.Error))
                MessageBox.Show("Device is now rebooting.", "Success", MessageBoxButtons.OK, MessageBoxIcon.Information);
            else
                MessageBox.Show("Reboot failed. See log for details.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
        }

        /// <summary>
        /// Open file dialog to select an APK. Selected path placed into textBox1.
        /// Non-blocking UI operations; uses OpenFileDialog.ShowDialog synchronous call on UI thread.
        /// </summary>
        private void button2_Click(object? sender, EventArgs e)
        {
            // Safety: ensure the OpenFileDialog control exists (Designer may not have created it).
            if (openFileDialog1 == null)
            {
                MessageBox.Show("OpenFileDialog not initialized.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            // Configure reasonable defaults for the dialog
            openFileDialog1.InitialDirectory = @"C:\"; // start at C: by default
            openFileDialog1.Title = "Select your APK"; // dialog title
            openFileDialog1.FileName = string.Empty; // clear filename
            openFileDialog1.CheckFileExists = true; // require selected file exists
            openFileDialog1.CheckPathExists = true; // require valid path
            openFileDialog1.Filter = ".APK|*.apk"; // filter to apk files only

            // Show file dialog and update the text box with chosen filename when OK pressed
            if (openFileDialog1.ShowDialog() == DialogResult.OK && !string.IsNullOrWhiteSpace(openFileDialog1.FileName))
            {
                if (textBox1 != null) textBox1.Text = openFileDialog1.FileName; // set selected APK path
            }
        }

        // TextChanged handler for the APK path textbox; currently only logs the change
        private void textBox1_TextChanged(object? sender, EventArgs e)
        {
            // Could enable/disable InstallApk control here based on path validity; currently logs for debugging
            AppendLog($"APK path changed: {textBox1?.Text}");
        }

        // OpenFileDialog.FileOk event placeholder; actual handling done in button2_Click
        private void openFileDialog1_FileOk(object? sender, System.ComponentModel.CancelEventArgs e)
        {
            // Method intentionally left blank: button2_Click handles dialog results
        }

        /// <summary>
        /// Install selected APK using adb install -r. Targets selected device if any via -s &lt;serial&gt;.
        /// This checks file existence, ensures adb is present and device is connected, then executes install.
        /// </summary>
        private async void button3_Click(object? sender, EventArgs e)
        {
            // Read APK path from textBox1 (may be null if control is missing)
            string? apkPath = textBox1?.Text;

            // Validate apkPath is non-empty and file exists on disk
            if (string.IsNullOrWhiteSpace(apkPath) || !File.Exists(apkPath))
            {
                MessageBox.Show("Please select a valid APK file first.", "APK Missing", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Ensure adb exists
            if (!EnsureAdbAvailable()) return;

            // Confirm at least one device is connected (or explicit target selected)
            var devicesResult = await RunAdbCommandAsync("devices");
            if (!IsDeviceConnected(devicesResult.Output) && selectedDeviceSerial == null)
            {
                MessageBox.Show("No device detected or device unauthorized. Run adb devices and accept the USB debugging prompt on the device.", "ADB Device", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Quote the apk path to preserve spaces and log intent
            string apkQuoted = $"\"{apkPath}\"";
            AppendLog($"Installing APK: {apkPath} on {selectedDeviceSerial ?? "any"}");

            // Execute adb install -r "<apkPath>" optionally targeting a serial
            var result = await RunAdbCommandAsync($"install -r {apkQuoted}", selectedDeviceSerial);

            // Log the result
            AppendLog($"Install result Exit:{result.ExitCode} Err:{result.Error.Trim()} Out:{result.Output.Trim()}");

            // Check typical adb success conditions: exit code 0, no stderr, and stdout contains "success"
            if (result.ExitCode == 0 && string.IsNullOrWhiteSpace(result.Error) && result.Output.IndexOf("success", StringComparison.OrdinalIgnoreCase) >= 0)
                MessageBox.Show(".APK installed successfully.", "Installed", MessageBoxButtons.OK, MessageBoxIcon.Information);
            else
                MessageBox.Show("Install failed. See log for details.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
        }

        #endregion

        #region Format / Download mode / Recovery

        /// <summary>
        /// Destructive factory reset action. Requires explicit confirmation text "FORMAT".
        /// Attempts broadcast; falls back to reboot recovery if broadcast blocked.
        /// Targets selected device if any.
        /// </summary>
        private async void Format_Click(object? sender, EventArgs e)
        {
            // First confirmation step via standard message box (OK/Cancel)
            var prompt = MessageBox.Show("Formatting the device will erase user data and restore factory defaults.\n\nClick OK to continue to confirmation step.", "Confirm Format", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
            if (prompt != DialogResult.OK) return; // abort if user cancels

            // Second confirmation: explicit typed confirmation via InputBox
            string confirmation = Interaction.InputBox("Type FORMAT to confirm device factory reset", "Confirm Format", string.Empty);
            if (!string.Equals(confirmation, "FORMAT", StringComparison.OrdinalIgnoreCase))
            {
                MessageBox.Show("Format cancelled. Confirmation did not match.", "Cancelled", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return; // abort if confirmation does not match
            }

            // Ensure adb available and at least one connected device (or explicit target selected)
            if (!EnsureAdbAvailable()) return;
            var devicesResult = await RunAdbCommandAsync("devices");
            if (!IsDeviceConnected(devicesResult.Output) && selectedDeviceSerial == null)
            {
                MessageBox.Show("No device detected or device unauthorized. Run adb devices and accept the USB debugging prompt on the device.", "ADB Device", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Attempt to trigger the master clear broadcast on device
            AppendLog($"Attempting format (MASTER_CLEAR) on {selectedDeviceSerial ?? "any"}");
            var result = await RunAdbCommandAsync("shell am broadcast -a android.intent.action.MASTER_CLEAR", selectedDeviceSerial);
            AppendLog($"Format attempt Exit:{result.ExitCode} Err:{result.Error.Trim()} Out:{result.Output.Trim()}");

            // If broadcast succeeded (exit code 0 and no stderr), inform user that device will reset
            if (result.ExitCode == 0 && string.IsNullOrWhiteSpace(result.Error))
            {
                MessageBox.Show("Format command sent. If the device supported the broadcast it will perform a factory reset.", "Format Sent", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else
            {
                // Fallback strategy: reboot device into recovery where user can perform manual factory reset
                AppendLog("MASTER_CLEAR failed or blocked; rebooting to recovery as fallback.");
                var fallback = await RunAdbCommandAsync("reboot recovery", selectedDeviceSerial);
                AppendLog($"Reboot recovery result Exit:{fallback.ExitCode} Err:{fallback.Error.Trim()} Out:{fallback.Output.Trim()}");
                MessageBox.Show("Automatic format failed or was blocked. Device rebooted to recovery. Use the recovery menu to perform a factory reset.", "Format Fallback", MessageBoxButtons.OK, MessageBoxIcon.Warning);
            }
        }

        /// <summary>
        /// Reboot to bootloader (download mode). Uses adb reboot bootloader.
        /// Targets selected device if any.
        /// </summary>
        private async void Downloadmode_Click(object? sender, EventArgs e)
        {
            // Ensure adb and device availability
            if (!EnsureAdbAvailable()) return;
            var devicesResult = await RunAdbCommandAsync("devices");
            if (!IsDeviceConnected(devicesResult.Output) && selectedDeviceSerial == null)
            {
                MessageBox.Show("No device detected or device unauthorized. Run adb devices and accept the USB debugging prompt on the device.", "ADB Device", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Log and execute reboot bootloader
            AppendLog($"Rebooting to bootloader for {selectedDeviceSerial ?? "any"}");
            var result = await RunAdbCommandAsync("reboot bootloader", selectedDeviceSerial);
            AppendLog($"Bootloader result Exit:{result.ExitCode} Err:{result.Error.Trim()} Out:{result.Output.Trim()}");

            // Notify user of success or failure
            if (result.ExitCode == 0 && string.IsNullOrWhiteSpace(result.Error))
                MessageBox.Show("Device is rebooting to bootloader/download mode.", "Rebooting", MessageBoxButtons.OK, MessageBoxIcon.Information);
            else
                MessageBox.Show("Reboot to bootloader failed. See log for details.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
        }

        /// <summary>
        /// Reboot to recovery using adb reboot recovery. Targets selected device if any.
        /// </summary>
        private async void Recovery_Click(object? sender, EventArgs e)
        {
            // Validate adb and device presence
            if (!EnsureAdbAvailable()) return;
            var devicesResult = await RunAdbCommandAsync("devices");
            if (!IsDeviceConnected(devicesResult.Output) && selectedDeviceSerial == null)
            {
                MessageBox.Show("No device detected or device unauthorized. Run adb devices and accept the USB debugging prompt on the device.", "ADB Device", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Log and execute reboot recovery
            AppendLog($"Rebooting to recovery for {selectedDeviceSerial ?? "any"}");
            var result = await RunAdbCommandAsync("reboot recovery", selectedDeviceSerial);
            AppendLog($"Recovery result Exit:{result.ExitCode} Err:{result.Error.Trim()} Out:{result.Output.Trim()}");

            // Inform user about outcome
            if (result.ExitCode == 0 && string.IsNullOrWhiteSpace(result.Error))
                MessageBox.Show("Device is rebooting to recovery.", "Rebooting", MessageBoxButtons.OK, MessageBoxIcon.Information);
            else
                MessageBox.Show("Reboot to recovery failed. See log for details.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
        }

        #endregion

        #region Device listing and selection

        /// <summary>
        /// Handler for RefreshDevices button click. Refreshes the device list asynchronously.
        /// </summary>
        private async void RefreshDevices_Click(object? sender, EventArgs e)
        {
            await RefreshDeviceListAsync(); // call the central refresh routine
        }

        /// <summary>
        /// Refresh the DevicesListBox with connected devices using "adb devices -l".
        /// Parses adb output and builds friendly display strings per device.
        /// </summary>
        private async Task RefreshDeviceListAsync()
        {
            // If the listbox control isn't available, nothing to do
            if (DevicesListBox == null) return;

            // Show an immediate busy indicator text so user sees refresh is in progress
            DevicesListBox.Items.Clear(); // clear existing items
            DevicesListBox.Items.Add("Refreshing..."); // temporary placeholder

            // Ensure adb exists; if not, show an explanatory message in the list box and log it
            if (!EnsureAdbAvailable())
            {
                DevicesListBox.Items.Clear();
                DevicesListBox.Items.Add("ADB not found. Install Platform Tools and add to PATH.");
                AppendLog("ADB not found when refreshing devices.");
                return;
            }

            // Run "adb devices -l" which lists connected device serials and details
            var result = await RunAdbCommandAsync("devices -l");
            AppendLog($"Refreshed devices. Exit:{result.ExitCode} Err:{result.Error.Trim()}");

            // Prepare a list of display lines for the ListBox
            List<string> lines = new List<string>();

            // If adb returned a non-zero exit code, include error information
            if (result.ExitCode != 0)
            {
                lines.Add("adb failed to run. Error: " + result.Error);
            }
            // If adb returned nothing, note that
            else if (string.IsNullOrWhiteSpace(result.Output))
            {
                lines.Add("No output from adb.");
            }
            else
            {
                // Parse the adb output line by line
                using (StringReader sr = new StringReader(result.Output))
                {
                    string? line;
                    while ((line = sr.ReadLine()) != null)
                    {
                        line = line.Trim(); // trim surrounding whitespace
                        if (line.Length == 0) continue; // skip blank lines
                        if (line.StartsWith("List of devices", StringComparison.OrdinalIgnoreCase)) continue; // skip header

                        // Tokenize the line by whitespace, preserving meaningful tokens
                        var tokens = line.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                        if (tokens.Length >= 2)
                        {
                            // First token is serial, second is state (device/unauthorized/ offline)
                            string serial = tokens[0];
                            string state = tokens[1];
                            // Remaining tokens contain key:value details like model:X product:Y device:Z
                            string details = string.Join(" ", tokens.Skip(2));
                            // Extract known detail values if present
                            string model = TryExtractValue(details, "model");
                            string product = TryExtractValue(details, "product");
                            string deviceName = TryExtractValue(details, "device");
                            string usb = TryExtractValue(details, "usb");

                            // Build a friendly display string for the listbox item
                            string display = $"{serial} [{state}]";
                            if (!string.IsNullOrEmpty(model)) display += $" model:{model}";
                            else if (!string.IsNullOrEmpty(product)) display += $" product:{product}";
                            if (!string.IsNullOrEmpty(deviceName)) display += $" hw:{deviceName}";
                            if (!string.IsNullOrEmpty(usb)) display += $" usb:{usb}";

                            lines.Add(display); // add to the results list
                        }
                        else
                        {
                            // If line doesn't match expected pattern, include raw line for visibility
                            lines.Add(line);
                        }
                    }
                }

                // If parsing produced no device entries, inform the user
                if (lines.Count == 0)
                    lines.Add("No devices attached or output parsing produced no device entries.");
            }

            // Update the UI listbox on the UI thread; handle InvokeRequired when called from background thread
            if (DevicesListBox.InvokeRequired)
            {
                DevicesListBox.Invoke(new Action(() =>
                {
                    DevicesListBox.Items.Clear();
                    foreach (var l in lines) DevicesListBox.Items.Add(l);
                }));
            }
            else
            {
                DevicesListBox.Items.Clear();
                foreach (var l in lines) DevicesListBox.Items.Add(l);
            }

            // Clear previously selected serial because the list changed; user must reselect to target specific device
            selectedDeviceSerial = null;
            UpdateSelectedDeviceLabel(); // refresh label to show no target selected
        }

        /// <summary>
        /// When the user selects an entry in DevicesListBox, parse the serial (first token)
        /// and store it in selectedDeviceSerial so subsequent adb commands target it with -s.
        /// </summary>
        private void DevicesListBox_SelectedIndexChanged(object? sender, EventArgs e)
        {
            // Guard: control must exist
            if (DevicesListBox == null) return;

            // If nothing selected, clear selection state
            if (DevicesListBox.SelectedItem == null)
            {
                selectedDeviceSerial = null;
                UpdateSelectedDeviceLabel();
                return;
            }

            // Convert selected item to string and validate
            string line = DevicesListBox.SelectedItem.ToString() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(line))
            {
                selectedDeviceSerial = null;
                UpdateSelectedDeviceLabel();
                return;
            }

            // Tokenize selection and take first token as candidate serial
            var tokens = line.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            if (tokens.Length >= 1)
            {
                string candidate = tokens[0];
                // Ignore placeholder entries and error messages (do not treat them as device serials)
                if (candidate.Equals("Refreshing...", StringComparison.OrdinalIgnoreCase) ||
                    candidate.StartsWith("adb", StringComparison.OrdinalIgnoreCase) ||
                    candidate.Contains("No") || candidate.Contains("Error"))
                {
                    selectedDeviceSerial = null;
                    UpdateSelectedDeviceLabel();
                    return;
                }

                // Accept the candidate as the selected serial and log it
                selectedDeviceSerial = candidate;
                AppendLog($"Selected device: {selectedDeviceSerial}");
                UpdateSelectedDeviceLabel();
            }
            else
            {
                // No tokens found; clear selection
                selectedDeviceSerial = null;
                UpdateSelectedDeviceLabel();
            }
        }

        /// <summary>
        /// Helper to extract a value of the form "key:value" from a whitespace-separated details string.
        /// Returns empty string if not found or on malformed input.
        /// </summary>
        private static string TryExtractValue(string text, string key)
        {
            // Validate inputs
            if (string.IsNullOrEmpty(text) || string.IsNullOrEmpty(key)) return string.Empty;

            // Split the details string into parts separated by whitespace
            var parts = text.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            foreach (var p in parts)
            {
                var idx = p.IndexOf(':'); // find colon that separates key and value
                if (idx <= 0) continue; // skip if no colon or colon at start
                var k = p.Substring(0, idx); // left side of colon
                var v = p.Substring(idx + 1); // right side of colon
                // Compare keys case-insensitively and return value when matched
                if (string.Equals(k, key, StringComparison.OrdinalIgnoreCase))
                    return v;
            }
            return string.Empty; // not found
        }

        /// <summary>
        /// Returns true if adb devices output contains any device in "device" state.
        /// This method inspects lines for tokens that indicate an authorized device.
        /// </summary>
        private bool IsDeviceConnected(string? adbDevicesOutput)
        {
            // Quick failure if there's no output
            if (string.IsNullOrWhiteSpace(adbDevicesOutput)) return false;

            // Read the output line-by-line looking for "device" markers
            using (StringReader sr = new StringReader(adbDevicesOutput))
            {
                string? line;
                while ((line = sr.ReadLine()) != null)
                {
                    line = line.Trim(); // trim whitespace
                    if (line.Length == 0) continue; // skip blanks
                    if (line.StartsWith("List of devices", StringComparison.OrdinalIgnoreCase)) continue; // skip header

                    // Typical adb line ends with "\tdevice" or contains " device " when printed differently
                    if (line.EndsWith("\tdevice", StringComparison.OrdinalIgnoreCase) || line.Contains("\tdevice\t") || line.Contains(" device "))
                        return true; // at least one authorized device found
                }
            }
            return false; // no authorized device lines detected
        }

        #endregion

        #region adb helpers

        /// <summary>
        /// Ensure adb executable is available and inform user if not.
        /// Returns true when found; false otherwise (and shows message to user).
        /// </summary>
        private bool EnsureAdbAvailable()
        {
            var path = AdbPath; // call ResolveAdbPath via property
            if (string.IsNullOrEmpty(path))
            {
                // Notify user with a clear message about how to obtain adb
                MessageBox.Show("ADB executable not found. Install Platform Tools and add adb to your PATH or place adb.exe in C:\\platform-tools.", "ADB Not Found", MessageBoxButtons.OK, MessageBoxIcon.Error);
                AppendLog("ADB not found."); // log the issue for troubleshooting
                return false;
            }
            return true; // adb exists (either as "adb" or as an explicit path)
        }

        /// <summary>
        /// Resolve adb path: prefer "adb" on PATH (verified by running "adb version"), else check known file locations.
        /// Returns "adb" to invoke via PATH or the explicit full path, or null when not found.
        /// </summary>
        private string? ResolveAdbPath()
        {
            try
            {
                // Prepare a ProcessStartInfo to check "adb version" quickly
                var psi = new ProcessStartInfo("adb", "version")
                {
                    RedirectStandardOutput = true, // we don't need output, but start must succeed
                    RedirectStandardError = true,
                    UseShellExecute = false, // required for redirection
                    CreateNoWindow = true // prevent any window
                };
                using (var p = Process.Start(psi))
                {
                    if (p == null) goto lookupCandidates; // couldn't start process, fall back to known paths
                    if (!p.WaitForExit(2000)) // wait up to 2 seconds for adb to return
                    {
                        // If adb didn't exit quickly, assume it's on PATH and usable; return "adb" to let OS find it later
                        return "adb";
                    }
                    // If process exited with code 0, treat "adb" on PATH as valid
                    if (p.HasExited && p.ExitCode == 0) return "adb";
                }
            }
            catch
            {
                // Ignore exceptions; we'll try file-based lookup below
            }

        lookupCandidates:
            // If PATH-based check failed, inspect known Windows install locations
            foreach (var candidate in AdbCandidates)
            {
                // Skip the generic "adb" entry when enumerating to avoid duplicate check
                if (string.Equals(candidate, "adb", StringComparison.OrdinalIgnoreCase)) continue;
                if (File.Exists(candidate)) return candidate; // return the first existing path
            }

            // No candidate matched; return null to indicate adb not found
            return null;
        }

        /// <summary>
        /// Run adb with arguments on a background Task. If serial is provided, prepend "-s &lt;serial&gt;".
        /// Captures stdout/stderr and exit code into a ProcessResult object.
        /// </summary>
        private Task<ProcessResult> RunAdbCommandAsync(string arguments, string? serial = null)
        {
            // Run the operation on a ThreadPool thread to avoid blocking UI thread
            return Task.Run(() =>
            {
                var result = new ProcessResult(); // container to return
                string? adb = AdbPath; // resolve adb (calls ResolveAdbPath)
                if (string.IsNullOrEmpty(adb))
                {
                    result.ExitCode = -1; // indicate failure to start
                    result.Error = "adb not found"; // helpful error string
                    return result;
                }

                // If a serial is specified, prepend "-s <serial>" to target the specific device
                string fullArgs = string.IsNullOrEmpty(serial) ? arguments : $"-s {serial} {arguments}";

                // Build ProcessStartInfo for executing adb
                var psi = new ProcessStartInfo
                {
                    FileName = adb, // either "adb" or absolute path to adb.exe
                    Arguments = fullArgs, // assembled arguments
                    RedirectStandardOutput = true, // capture stdout
                    RedirectStandardError = true, // capture stderr
                    UseShellExecute = false, // required for redirection
                    CreateNoWindow = true // no console window
                };

                try
                {
                    using (var process = Process.Start(psi))
                    {
                        if (process == null)
                        {
                            // Process failed to start (Process.Start returned null)
                            result.ExitCode = -1;
                            result.Error = "Failed to start adb process.";
                            return result;
                        }

                        // Read both streams fully on the background thread to avoid deadlocks
                        string stdout = process.StandardOutput.ReadToEnd();
                        string stderr = process.StandardError.ReadToEnd();

                        // Wait for exit with a reasonable timeout to avoid hanging forever
                        process.WaitForExit(30000); // 30s timeout for adb calls

                        // If process exited, capture its exit code; otherwise -1 indicates timeout or abnormal termination
                        result.ExitCode = process.HasExited ? process.ExitCode : -1;
                        result.Output = stdout ?? string.Empty; // normalized to empty string when null
                        result.Error = stderr ?? string.Empty; // normalized to empty string when null
                    }
                }
                catch (Exception ex)
                {
                    // Catch exceptions and return them in the Error property for diagnostics
                    result.ExitCode = -1;
                    result.Error = ex.Message;
                }

                return result; // return the collected result
            });
        }

        /// <summary>
        /// Simple container for process results.
        /// Holds ExitCode, Output (stdout), and Error (stderr).
        /// </summary>
        private class ProcessResult
        {
            public int ExitCode { get; set; } // process exit code returned by adb
            public string Output { get; set; } = string.Empty; // stdout content
            public string Error { get; set; } = string.Empty; // stderr content
        }

        #endregion

        #region File push / pull

        /// <summary>
        /// Push a local file or folder to the device. remotePath must be a writable path on device (e.g., /sdcard/).
        /// Returns ProcessResult with adb output/error.
        /// </summary>
        private async Task<ProcessResult> PushFileAsync(string localPath, string remotePath, string? serial = null)
        {
            // Validate local path exists (file or directory)
            if (string.IsNullOrWhiteSpace(localPath) || (!File.Exists(localPath) && !Directory.Exists(localPath)))
            {
                return new ProcessResult { ExitCode = -1, Error = "Local path not found." }; // early failure
            }

            // Quote both paths to handle spaces and build adb push args
            string args = $"push \"{localPath}\" \"{remotePath}\"";
            return await RunAdbCommandAsync(args, serial); // run adb push asynchronously
        }

        /// <summary>
        /// Pull a file or folder from device to a local path.
        /// Ensures the destination directory exists (attempts to create it).
        /// </summary>
        private async Task<ProcessResult> PullFileAsync(string remotePath, string localPath, string? serial = null)
        {
            try
            {
                // Ensure local directory exists to avoid adb pull errors due to missing path
                var dir = Path.GetDirectoryName(localPath);
                if (!string.IsNullOrEmpty(dir)) Directory.CreateDirectory(dir);
            }
            catch { /* ignore directory creation errors here; adb may still fail and return useful error */ }

            // Build adb pull arguments with quoted paths
            string args = $"pull \"{remotePath}\" \"{localPath}\"";
            return await RunAdbCommandAsync(args, serial); // execute adb pull
        }

        /// <summary>
        /// UI wrapper for pushing a file; wired to PushFileBtn.
        /// Prompts user for a file to push and a remote destination path.
        /// </summary>
        private async void PushFile_Click(object? sender, EventArgs e)
        {
            // Prompt user to choose a local file
            using var ofd = new OpenFileDialog { Title = "Select file to push", CheckFileExists = true };
            if (ofd.ShowDialog() != DialogResult.OK) return; // abort if user cancelled
            string local = ofd.FileName; // chosen local file

            // Prompt user for remote path; default suggestion uses same filename on /sdcard/
            string remote = Interaction.InputBox("Enter remote path on device (e.g., /sdcard/filename.ext):", "Remote Path", $"/sdcard/{Path.GetFileName(local)}");
            if (string.IsNullOrWhiteSpace(remote)) return; // abort if user cancelled input

            // Set UI busy state and execute push
            SetBusy(true, "Pushing file...");
            AppendLog($"Pushing {local} -> {remote} (target {selectedDeviceSerial ?? "any"})");
            var res = await PushFileAsync(local, remote, selectedDeviceSerial);
            AppendLog($"Push result Exit:{res.ExitCode} Err:{res.Error.Trim()} Out:{res.Output.Trim()}");
            SetBusy(false);

            // Show results to the user with stdout and stderr content
            MessageBox.Show("Push result:\n\nOutput:\n" + res.Output + "\n\nError:\n" + res.Error, "Push Result", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        /// <summary>
        /// UI wrapper for pulling a file; wired to PullFileBtn.
        /// Prompts for remote path then local save destination.
        /// </summary>
        private async void PullFile_Click(object? sender, EventArgs e)
        {
            // Ask for remote path to pull from device
            string remote = Interaction.InputBox("Enter remote path on device to pull (e.g., /sdcard/file.txt):", "Remote Path", "/sdcard/");
            if (string.IsNullOrWhiteSpace(remote)) return; // abort if cancelled

            // Ask for local save path using SaveFileDialog with suggested filename from remote path
            using var sfd = new SaveFileDialog { Title = "Save pulled file as", FileName = Path.GetFileName(remote) };
            if (sfd.ShowDialog() != DialogResult.OK) return; // abort if user cancelled
            string local = sfd.FileName;

            // Execute pull with busy UI state
            SetBusy(true, "Pulling file...");
            AppendLog($"Pulling {remote} -> {local} (target {selectedDeviceSerial ?? "any"})");
            var res = await PullFileAsync(remote, local, selectedDeviceSerial);
            AppendLog($"Pull result Exit:{res.ExitCode} Err:{res.Error.Trim()} Out:{res.Output.Trim()}");
            SetBusy(false);

            // Show results to the user
            MessageBox.Show("Pull result:\n\nOutput:\n" + res.Output + "\n\nError:\n" + res.Error, "Pull Result", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        #endregion

        #region Batch APK install / uninstall

        /// <summary>
        /// Install a single APK using adb install -r. Returns ProcessResult.
        /// </summary>
        private async Task<ProcessResult> InstallApkAsync(string apkPath, string? serial = null)
        {
            // Ensure apk file exists before attempting install
            if (!File.Exists(apkPath)) return new ProcessResult { ExitCode = -1, Error = "APK not found." };
            string args = $"install -r \"{apkPath}\""; // build quoted install args with -r to replace existing
            return await RunAdbCommandAsync(args, serial); // execute adb install
        }

        /// <summary>
        /// Install multiple APKs sequentially and return per-apk results.
        /// This method runs installs one after another (not parallel).
        /// </summary>
        private async Task<Dictionary<string, ProcessResult>> BatchInstallAsync(IEnumerable<string> apkPaths, string? serial = null)
        {
            var results = new Dictionary<string, ProcessResult>(); // hold per-file results
            foreach (var apk in apkPaths)
            {
                AppendLog($"Installing {apk} on {serial ?? "any"}"); // log each install
                var res = await InstallApkAsync(apk, serial); // install and await completion
                results[apk] = res; // store result
            }
            return results; // return aggregated results
        }

        /// <summary>
        /// Uninstall a package by package name (e.g., com.example.app).
        /// keepData indicates whether to preserve app data (-k).
        /// </summary>
        private async Task<ProcessResult> UninstallPackageAsync(string packageName, bool keepData = false, string? serial = null)
        {
            // Validate package name
            if (string.IsNullOrWhiteSpace(packageName)) return new ProcessResult { ExitCode = -1, Error = "Package name required." };
            string args = keepData ? $"uninstall -k {packageName}" : $"uninstall {packageName}"; // choose args based on keepData
            return await RunAdbCommandAsync(args, serial); // execute uninstall
        }

        /// <summary>
        /// Batch uninstall by package name list.
        /// Returns a dictionary of package -> ProcessResult.
        /// </summary>
        private async Task<Dictionary<string, ProcessResult>> BatchUninstallAsync(IEnumerable<string> packageNames, string? serial = null)
        {
            var results = new Dictionary<string, ProcessResult>();
            foreach (var pkg in packageNames)
            {
                AppendLog($"Uninstalling {pkg} on {serial ?? "any"}"); // log each uninstall
                var res = await UninstallPackageAsync(pkg, false, serial); // uninstall without keeping data
                results[pkg] = res; // store result
            }
            return results;
        }

        /// <summary>
        /// UI wrapper for batch installing APKs; wired to BatchInstallBtn.
        /// Prompts user to select multiple APK files and runs BatchInstallAsync.
        /// </summary>
        private async void BatchInstall_Click(object? sender, EventArgs e)
        {
            // Allow multiple selection of APK files via OpenFileDialog
            using var ofd = new OpenFileDialog { Multiselect = true, Filter = ".APK|*.apk", Title = "Select APKs to install" };
            if (ofd.ShowDialog() != DialogResult.OK) return; // abort if cancelled
            var apkFiles = ofd.FileNames; // selected files array

            // Indicate busy state and perform batch install
            SetBusy(true, "Installing APKs...");
            var results = await BatchInstallAsync(apkFiles, selectedDeviceSerial);
            SetBusy(false);

            // Build a summary string with per-file exit codes and errors
            var sb = new StringBuilder();
            foreach (var kv in results)
            {
                sb.AppendLine($"{Path.GetFileName(kv.Key)} => Exit:{kv.Value.ExitCode} Error:{kv.Value.Error.Trim()}");
            }

            AppendLog("Batch install completed."); // log completion
            MessageBox.Show(sb.ToString(), "Batch Install Results", MessageBoxButtons.OK, MessageBoxIcon.Information); // show details to user
        }

        /// <summary>
        /// UI wrapper for batch uninstall; wired to BatchUninstallBtn.
        /// Prompts for comma-separated package names.
        /// </summary>
        private async void BatchUninstall_Click(object? sender, EventArgs e)
        {
            // Prompt the user for a comma-separated list of package names
            string input = Interaction.InputBox("Enter package names to uninstall, separated by commas (e.g., com.example.app,com.other.app):", "Batch Uninstall", "");
            if (string.IsNullOrWhiteSpace(input)) return; // abort if cancelled or empty

            // Parse input into a trimmed list of package names
            var packages = input.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries).Select(x => x.Trim()).Where(x => x.Length > 0).ToList();
            if (packages.Count == 0) return; // nothing to uninstall

            // Perform batch uninstall and show results
            SetBusy(true, "Uninstalling packages...");
            var results = await BatchUninstallAsync(packages, selectedDeviceSerial);
            SetBusy(false);

            // Summarize results into a message
            var sb = new StringBuilder();
            foreach (var kv in results)
            {
                sb.AppendLine($"{kv.Key} => Exit:{kv.Value.ExitCode} Error:{kv.Value.Error.Trim()} Output:{kv.Value.Output.Trim()}");
            }

            AppendLog("Batch uninstall completed.");
            MessageBox.Show(sb.ToString(), "Batch Uninstall Results", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        #endregion

        #region Device info and diagnostics

        /// <summary>
        /// Run dumpsys for a specific service (e.g., "battery", "meminfo", "sensorservice") and return the text output.
        /// Uses adb shell dumpsys &lt;service&gt;.
        /// </summary>
        private async Task<ProcessResult> GetDumpsysAsync(string service, string? serial = null)
        {
            // Validate service parameter
            if (string.IsNullOrWhiteSpace(service)) return new ProcessResult { ExitCode = -1, Error = "Service required." };
            string args = $"shell dumpsys {service}"; // build arguments
            return await RunAdbCommandAsync(args, serial); // execute adb shell dumpsys
        }

        /// <summary>
        /// Convenience helper that queries dumpsys battery and summarizes important fields.
        /// Returns a short human-readable summary or full output if no key lines found.
        /// </summary>
        private async Task<string> GetBatterySummaryAsync(string? serial = null)
        {
            var res = await GetDumpsysAsync("battery", serial); // get dumpsys battery output
            if (res.ExitCode != 0) return "Error: " + res.Error; // return error if dumpsys failed

            var sb = new StringBuilder();
            using (var sr = new StringReader(res.Output))
            {
                string? line;
                // Read each line and capture only lines of interest for a concise summary
                while ((line = sr.ReadLine()) != null)
                {
                    line = line.Trim();
                    if (line.StartsWith("level:", StringComparison.OrdinalIgnoreCase)
                        || line.StartsWith("status:", StringComparison.OrdinalIgnoreCase)
                        || line.StartsWith("health:", StringComparison.OrdinalIgnoreCase)
                        || line.StartsWith("voltage:", StringComparison.OrdinalIgnoreCase)
                        || line.StartsWith("temperature:", StringComparison.OrdinalIgnoreCase)
                        || line.StartsWith("present:", StringComparison.OrdinalIgnoreCase))
                    {
                        sb.AppendLine(line); // append interesting battery info lines
                    }
                }
            }

            // If no key lines found, return full dumpsys output for completeness
            return sb.Length == 0 ? res.Output : sb.ToString();
        }

        /// <summary>
        /// Convenience helper to get a short diagnostics bundle (battery + meminfo + top of sensorservice).
        /// Returns concatenated string with labeled sections.
        /// </summary>
        private async Task<string> GetDiagnosticsSummaryAsync(string? serial = null)
        {
            var sb = new StringBuilder();

            // Battery section
            sb.AppendLine("=== Battery ===");
            sb.AppendLine(await GetBatterySummaryAsync(serial));

            // Meminfo section: capture first ~40 lines for a concise top-of-output snapshot
            sb.AppendLine();
            sb.AppendLine("=== Meminfo (top) ===");
            var mem = await GetDumpsysAsync("meminfo", serial);
            if (mem.ExitCode == 0)
            {
                using (var sr = new StringReader(mem.Output))
                {
                    for (int i = 0; i < 40; i++)
                    {
                        var l = sr.ReadLine();
                        if (l == null) break;
                        sb.AppendLine(l);
                    }
                }
            }
            else sb.AppendLine("meminfo error: " + mem.Error);

            // Sensorservice section: capture first ~60 lines
            sb.AppendLine();
            sb.AppendLine("=== Sensors (partial) ===");
            var sensors = await GetDumpsysAsync("sensorservice", serial);
            if (sensors.ExitCode == 0)
            {
                using (var sr = new StringReader(sensors.Output))
                {
                    for (int i = 0; i < 60; i++)
                    {
                        var l = sr.ReadLine();
                        if (l == null) break;
                        sb.AppendLine(l);
                    }
                }
            }
            else sb.AppendLine("sensorservice error: " + sensors.Error);

            // Return assembled diagnostics text
            return sb.ToString();
        }

        /// <summary>
        /// UI wrapper to show device diagnostics in a dialog; wired to ShowDeviceInfoBtn.
        /// Collects diagnostics and shows them in a read-only multi-line TextBox inside a dialog Form.
        /// </summary>
        private async void ShowDeviceInfo_Click(object? sender, EventArgs e)
        {
            // Ensure adb exists and a target device is available
            if (!EnsureAdbAvailable()) return;

            var devicesResult = await RunAdbCommandAsync("devices -l");
            if (!IsDeviceConnected(devicesResult.Output) && selectedDeviceSerial == null)
            {
                MessageBox.Show("No device detected or device unauthorized. Run adb devices and accept the USB debugging prompt on the device.", "ADB Device", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Collect diagnostics with busy UI indicator
            SetBusy(true, "Collecting diagnostics...");
            var summary = await GetDiagnosticsSummaryAsync(selectedDeviceSerial);
            SetBusy(false);

            // Create a temporary dialog form to display diagnostic text in a monospace TextBox
            using (var dlg = new Form { Width = 800, Height = 600, Text = "Device Diagnostics" })
            {
                var tb = new TextBox { Multiline = true, ReadOnly = true, ScrollBars = ScrollBars.Both, Dock = DockStyle.Fill, Font = new System.Drawing.Font("Consolas", 9) };
                tb.Text = summary; // set diagnostic content
                dlg.Controls.Add(tb); // add textbox to dialog
                dlg.StartPosition = FormStartPosition.CenterParent; // center dialog relative to parent
                dlg.ShowDialog(this); // show modal dialog
            }
        }

        #endregion

        #region UI helpers: logging, busy state, selected device label update

        /// <summary>
        /// Append a single line to the LogTextBox safely from any thread.
        /// Uses Invoke when called from non-UI thread to avoid cross-thread exceptions.
        /// </summary>
        private void AppendLog(string text)
        {
            try
            {
                if (LogTextBox == null) return; // nothing to do if log control missing
                string line = $"[{DateTime.Now:HH:mm:ss}] {text}{Environment.NewLine}"; // timestamped line
                if (LogTextBox.InvokeRequired)
                    LogTextBox.Invoke(new Action(() => LogTextBox.AppendText(line))); // marshal to UI thread
                else
                    LogTextBox.AppendText(line); // direct append when already on UI thread
            }
            catch
            {
                // Swallow logging exceptions to avoid crashing UI for non-critical logging
            }
        }

        /// <summary>
        /// Set UI busy state: enable/disable main action buttons and manage progress bar.
        /// statusText optionally appears in SelectedDeviceLabel while busy.
        /// </summary>
        private void SetBusy(bool busy, string statusText = "")
        {
            try
            {
                // If an OperationProgressBar control exists, adjust its style and visibility
                if (OperationProgressBar != null)
                {
                    if (busy)
                    {
                        OperationProgressBar.Style = ProgressBarStyle.Marquee; // indeterminate animation
                        OperationProgressBar.Visible = true; // show progress bar
                    }
                    else
                    {
                        OperationProgressBar.Style = ProgressBarStyle.Blocks; // reset style
                        OperationProgressBar.Visible = false; // hide progress bar
                    }
                }

                // Disable or enable primary action controls while busy to avoid reentrancy
                Action<bool> setEnabled = enabled =>
                {
                    if (Reboot != null) Reboot.Enabled = enabled;
                    if (InstallApk != null) InstallApk.Enabled = enabled;
                    if (Downloadmode != null) Downloadmode.Enabled = enabled;
                    if (Recovery != null) Recovery.Enabled = enabled;
                    if (Format != null) Format.Enabled = enabled;
                    if (PushFileBtn != null) PushFileBtn.Enabled = enabled;
                    if (PullFileBtn != null) PullFileBtn.Enabled = enabled;
                    if (BatchInstallBtn != null) BatchInstallBtn.Enabled = enabled;
                    if (BatchUninstallBtn != null) BatchUninstallBtn.Enabled = enabled;
                    if (ShowDeviceInfoBtn != null) ShowDeviceInfoBtn.Enabled = enabled;
                    if (RefreshDevices != null) RefreshDevices.Enabled = enabled;
                };

                // Apply inverted busy state (disable controls when busy = true)
                setEnabled(!busy);

                // Optionally update a status label with the provided statusText while busy
                if (SelectedDeviceLabel != null)
                {
                    if (busy)
                        SelectedDeviceLabel.Text = string.IsNullOrEmpty(statusText) ? "Working..." : statusText;
                    else
                        UpdateSelectedDeviceLabel(); // restore selected device text when not busy
                }
            }
            catch { /* ignore UI update faults to avoid crashing from non-critical UI updates */ }
        }

        /// <summary>
        /// Update SelectedDeviceLabel text to reflect currently selected device serial.
        /// If no serial selected, displays "Target: (none)".
        /// </summary>
        private void UpdateSelectedDeviceLabel()
        {
            if (SelectedDeviceLabel == null) return; // nothing to update if control missing
            try
            {
                if (string.IsNullOrEmpty(selectedDeviceSerial))
                    SelectedDeviceLabel.Text = "Target: (none)"; // no target selected
                else
                    SelectedDeviceLabel.Text = $"Target: {selectedDeviceSerial}"; // show selected serial
            }
            catch { /* ignore label update exceptions */ }
        }

        #endregion

        // Optional designer lifecycle method left intentionally blank (exists to satisfy Designer wiring)
        private void Form1_Load(object sender, EventArgs e) { }

        // Close button click simply closes the form
        private void CloseButton_Click(object sender, EventArgs e)
        {
            Close(); // close the main form and exit application if it's the main form
        }

        // Designer-forwarding wrappers for event names wired in InitializeComponent
        // These methods call the implemented handlers above to satisfy Designer-generated event wiring.
        private void BatchInstallBtn_Click(object sender, EventArgs e) { BatchInstall_Click(sender, e); }
        private void BatchUninstallBtn_Click(object sender, EventArgs e) { BatchUninstall_Click(sender, e); }
        private void PushFileBtn_Click(object sender, EventArgs e) { PushFile_Click(sender, e); }
        private void PullFileBtn_Click(object sender, EventArgs e) { PullFile_Click(sender, e); }
        private void ShowDeviceInfoBtn_Click(object sender, EventArgs e) { ShowDeviceInfo_Click(sender, e); }

        // Click of the selected device label refreshes the displayed label text
        private void SelectedDeviceLabel_Click(object sender, EventArgs e) => UpdateSelectedDeviceLabel();

        // Placeholder event handlers to satisfy Designer wiring; they intentionally do nothing
        private void LogTextBox_TextChanged(object sender, EventArgs e) { /* placeholder to satisfy Designer wiring */ }
        private void OperationProgressBar_Click(object sender, EventArgs e) { /* placeholder to satisfy Designer wiring */ }
    }
}